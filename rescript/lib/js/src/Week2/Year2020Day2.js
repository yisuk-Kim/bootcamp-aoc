// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Fs = require("fs");
var Belt_Int = require("rescript/lib/js/belt_Int.js");
var Belt_Array = require("rescript/lib/js/belt_Array.js");
var Belt_Option = require("rescript/lib/js/belt_Option.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

var input = Fs.readFileSync("input/Week2/Year2020Day2.input.txt", "utf8");

function parsePassword(input) {
  var splitInfo = function (input) {
    return input.split(/\s|-|:\s/);
  };
  var liftOptionUp = function (input) {
    if (Belt_Array.some(input, Belt_Option.isNone)) {
      return ;
    } else {
      return Belt_Array.keepMap(input, (function (x) {
                    return x;
                  }));
    }
  };
  var stringArrayToPassword = function (data) {
    var min = Belt_Array.get(data, 0);
    var max = Belt_Array.get(data, 1);
    var letter = Belt_Array.get(data, 2);
    var pw = Belt_Array.get(data, 3);
    if (min !== undefined && max !== undefined && letter !== undefined && pw !== undefined) {
      return {
              min: Belt_Option.getWithDefault(Belt_Int.fromString(min), 0),
              max: Belt_Option.getWithDefault(Belt_Int.fromString(max), 0),
              letter: letter,
              pw: pw
            };
    }
    
  };
  return Belt_Array.map(Belt_Array.map(Belt_Array.map(input.split("\n"), splitInfo), liftOptionUp), (function (x) {
                return Belt_Option.flatMap(x, stringArrayToPassword);
              }));
}

function checkValidity(data) {
  var countOccurrence = function (data) {
    return Belt_Option.mapWithDefault(Caml_option.null_to_opt(data.pw.match(new RegExp(data.letter, "g"))), 0, (function (prim) {
                  return prim.length;
                }));
  };
  var num = countOccurrence(data);
  var min = data.min;
  var max = data.max;
  var match = num >= min;
  var match$1 = num <= max;
  if (match && match$1) {
    return true;
  } else {
    return false;
  }
}

function count(boolArray) {
  var boolToInt = function (x) {
    if (x) {
      return 1;
    } else {
      return 0;
    }
  };
  var array = Belt_Array.map(boolArray, boolToInt);
  return Belt_Array.reduce(array, 0, (function (acc, x) {
                return acc + x | 0;
              }));
}

console.log(count(Belt_Array.keepMap(Belt_Array.map(parsePassword(input), (function (x) {
                    return Belt_Option.map(x, checkValidity);
                  })), (function (x) {
                return x;
              }))));

function checkValidity2(data) {
  var checkPosition = function (pos, letter, pw) {
    return pw.charAt(pos - 1 | 0) === letter;
  };
  var match = checkPosition(data.min, data.letter, data.pw);
  var match$1 = checkPosition(data.max, data.letter, data.pw);
  if (match) {
    if (match$1) {
      return false;
    } else {
      return true;
    }
  } else if (match$1) {
    return true;
  } else {
    return false;
  }
}

console.log(count(Belt_Array.keepMap(Belt_Array.map(parsePassword(input), (function (x) {
                    return Belt_Option.map(x, checkValidity2);
                  })), (function (x) {
                return x;
              }))));

exports.input = input;
exports.parsePassword = parsePassword;
exports.checkValidity = checkValidity;
exports.count = count;
exports.checkValidity2 = checkValidity2;
/* input Not a pure module */
